<?php

namespace Modules\Production\App\Repositories;


use Doctrine\ORM\EntityRepository;
use Modules\Production\App\Entities\InvoiceKeyValue;
use Modules\Production\App\Entities\ProductionBatch;
use Modules\Production\App\Entities\ProductionWorkOrder;


/**
 * ItemKeyValueRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class InvoiceKeyValueRepository extends EntityRepository
{

    public function insertWorkOrderKeyValue(ProductionWorkOrder $reEntity,$data)
    {

        $em = $this->_em;
        $i=0;
        if(isset($data['metaKey']) OR isset($data['metaValue']) ){
            foreach ($data['metaKey'] as $value) {
                $metaId = isset($data['metaId'][$i]) ? $data['metaId'][$i] : 0 ;
                $itemKeyValue = $this->_em->getRepository('TerminalbdProductionBundle:InvoiceKeyValue')->findOneBy(array('workorder'=>$reEntity,'id' => $metaId));
                if(!empty($metaId) and !empty($itemKeyValue)){
                    $this->updateMetaAttribute($itemKeyValue,$data['metaKey'][$i],$data['metaValue'][$i]);
                }else{
                    if(!empty($data['metaKey'][$i]) OR !empty($data['metaValue'][$i]))
                    {
                        $entity = new InvoiceKeyValue();
                        $entity->setMetaKey($data['metaKey'][$i]);
                        $entity->setMetaValue($data['metaValue'][$i]);
                        $entity->setWorkorder($reEntity);
                        $em->persist($entity);
                        $em->flush($entity);
                    }

                }
                $i++;
            }
        }
    }

    public function insertBatchKeyValue(ProductionBatch $reEntity,$data)
    {

        $em = $this->_em;
        $i=0;
        if(isset($data['metaKey']) OR isset($data['metaValue']) ){
            foreach ($data['metaKey'] as $value) {
                $metaId = isset($data['metaId'][$i]) ? $data['metaId'][$i] : 0 ;
                $itemKeyValue = $this->_em->getRepository('TerminalbdProductionBundle:InvoiceKeyValue')->findOneBy(array('batch'=>$reEntity,'id' => $metaId));
                if(!empty($metaId) and !empty($itemKeyValue)){
                    $this->updateMetaAttribute($itemKeyValue,$data['metaKey'][$i],$data['metaValue'][$i]);
                }else{
                    if(!empty($data['metaKey'][$i]) OR !empty($data['metaValue'][$i]))
                    {
                        $entity = new InvoiceKeyValue();
                        $entity->setMetaKey($data['metaKey'][$i]);
                        $entity->setMetaValue($data['metaValue'][$i]);
                        $entity->setBatch($reEntity);
                        $em->persist($entity);
                        $em->flush($entity);
                    }

                }
                $i++;
            }
        }
    }

    public function updateMetaAttribute(InvoiceKeyValue $itemKeyValue,$key,$value ='')
    {
            $em = $this->_em;
            $itemKeyValue->setMetaKey($key);
            $itemKeyValue->setMetaValue($value);
            $em->flush();
    }

    public function setDivOrdering($data)
    {
        $i = 1;
        $em = $this->_em;
        $qb = $em->createQueryBuilder();
        foreach ($data as $key => $value){
            $qb->update('TerminalbdProductionBundle:InvoiceKeyValue', 'mg')
                ->set('mg.sorting', $i)
                ->where('mg.id = :id')
                ->setParameter('id', $key)
                ->getQuery()
                ->execute();
            $i++;

        }

    }

}
